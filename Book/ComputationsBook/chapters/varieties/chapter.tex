\title{Ideals, Varieties and \Mtwo}
\titlerunning{Ideals, Varieties and \Mtwo}
\toctitle{Ideals, Varieties and \Mtwo}
\author{Bernd Sturmfels\thanks{Partially supported by
the National Science Foundation (DMS-9970254).}}
\authorrunning{B. Sturmfels}
% \institute{University of California at Berkeley, Department of Mathematics,
%   Berkeley, CA 94720, USA}
\maketitle

\begin{abstract}
This chapter introduces \Mtwo commands for
some elementary computations in algebraic geometry.
Familiarity with Gr\"obner bases is assumed.
\end{abstract}

Many students and researchers alike have their first encounter with
Gr\"ob\-ner bases through the delightful text books \cite{CLO1} and \cite{CLO2}
by David Cox, John Little and Donal O'Shea. This chapter illustrates
the use of \Mtwo for some computations discussed in these books.
It can be used as a supplement for an advanced undergraduate course or 
first-year graduate course in computational algebraic geometry. The
mathematically advanced reader will find this chapter a useful summary
of some basic \Mtwo commands.

\section{A Curve in Affine Three-Space}

Our first example concerns geometric objects in
(complex) affine 3-space. We start by
setting up the ring of polynomial functions with rational coefficients.
<<<R = QQ[x,y,z]>>>
Various monomial orderings are available in \Mtwo; since we did not specify
one explicitly, the monomials in the ring ${\tt R}$ will be sorted in 
graded reverse lexicographic order  \cite[\S I.2, Definition 6]{CLO1}.
We define an ideal generated by two polynomials
in this ring and assign it to the variable named 
{\tt curve}.

<<<curve = ideal( x^4-y^5, x^3-y^7 )>>>
We compute the reduced Gr\"obner basis of our ideal:
<<<gb curve>>>
By inspecting leading terms (and using \cite[\S 9.3, Theorem 8]{CLO1}),
we see that our ideal {\tt curve} does indeed 
define a one-dimensional affine variety. This can be tested directly
with the following commands in \Mtwo:
<<<dim curve>>>
<<<codim curve>>>
The {\it degree} of a curve in complex affine $3$-space is the 
number of intersection points with a general plane. It coincides
with the degree  \cite[\S 6.4]{CLO2} of the projective closure
\cite[\S 8.4]{CLO1} of our curve, which we compute as follows:
<<<degree curve>>>
The Gr\"obner basis in {\tt o3} contains two polynomials which are not
irreducible: they contain a factor of $x^3$. This shows that our curve
is not irreducible over ${\bf Q}$. We first extract the components
which are transverse to the plane $x=0$:
<<<curve1 = saturate(curve,ideal(x))>>>
And next we extract the component which lies in the plane $x=0$:
<<<curve2 = saturate(curve,curve1)>>>
The second component is a multiple line. Hence our input ideal was not radical.
To test equality of ideals we use the command {\tt ==}\indexcmd{==} .
<<<curve == radical curve>>>
We now replace our curve by its first component:
<<<curve = curve1>>>
<<<degree curve>>>
The ideal of this curve is radical:
<<<curve == radical curve>>>
Notice that the variable ${\bf z}$ does not appear
among the generators of the ideal. Our curve consists of
$13$ straight lines (over {\bf C}) parallel to the {\tt z}-axis.

\section{Intersecting Our Curve With a Surface}

In this section we explore basic operations on ideals,
starting with those described in \cite[\S 4.3]{CLO1}.
Consider the following surface in affine $3$-space:
<<<surface = ideal( x^5 + y^5 + z^5 - 1)>>>
The union of the curve and the surface is represented by the 
intersection of their ideals:
<<<theirunion = intersect(curve,surface)>>>
In this example this coincides with the product of the two ideals:
<<<curve*surface == theirunion>>>
The intersection of the curve and the surface is represented by the 
sum of their ideals. We get a finite set of points:
<<<ourpoints = curve + surface>>>
<<<dim ourpoints>>>
The number of points is sixty five:
<<<degree ourpoints>>>
Each of the points is multiplicity-free:
<<<degree radical ourpoints>>>
The number of points coincides with the number of 
monomials not in the initial ideal \cite[\S 2.2]{CLO2}.
These are called the {\it standard monomials}.
<<<staircase = ideal leadTerm ourpoints>>>
The {\tt basis} command can be used to list all the standard monomials
<<<T = R/staircase;>>>
<<<basis T>>>

The assignment of the quotient ring to the global variable {\tt T} had a side
effect: the variables {\tt x}, {\tt y}, and {\tt z} now have values in that
ring.
To bring the variables of {\tt R} to the fore again, we must say:
<<<use R;>>>
Every polynomial function on our 65 points can be written uniquely
as a linear combination of these standard monomials. This 
representation can be computed using the normal form command {\tt \%}\indexcmd{\%}.

<<<anyOldPolynomial = y^5*x^5-x^9-y^8+y^3*x^5>>>
<<<anyOldPolynomial % ourpoints>>>
Clearly, the normal form is zero if and only the polynomial is in the ideal.
<<<anotherPolynomial = y^5*x^5-x^9-y^8+y^3*x^4>>>
<<<anotherPolynomial % ourpoints>>>


\section{Changing the Ambient Polynomial Ring}

During a \Mtwo session it sometimes becomes necessary to change the
ambient ring in which the computations takes place. Our original
ring, defined in {\tt i1}, is the polynomial ring in three variables
over the field  {\bf Q} of rational numbers
with the graded reverse lexicographic order. In this section 
two modifications are made: first we replace the field of coefficients
by a finite field, and later we replace the  monomial order
by an elimination order.

An important operation in algebraic geometry is 
the decomposition of algebraic varieties
into irreducible components \cite[\S 4.6]{CLO1}.
Algebraic algorithms for this purpose are based on the
{\it primary decomposition} of ideals \cite[\S 4.7]{CLO1}.
A future version of \Mtwo will have an implementation of
primary decomposition over any polynomial ring.
The current version of \Mtwo has a command
{\tt decompose} for finding all the minimal primes of an ideal,
but, as it stands, this works only over a finite field.

Let us change our coefficient field to the field with $101$ elements:
<<<R' = ZZ/101[x,y,z];>>>

We next move our ideal from the previous section into the new ring
(fortunately, none of the coefficients of its generators have 101 in the
denominator):

<<<ourpoints' = substitute(ourpoints,R')>>>
<<<decompose ourpoints'>>>
Oops, that didn't fit on the display, so let's print them out one per line.
<<<oo / print @@ print;>>>
If we just want to see the degrees of the irreducible components, then
we say:
<<<ooo / degree>>>
Note that the expressions ${\tt oo}$ 
and ${\tt ooo}$ refer to the previous and
prior-to-previous output lines respectively.

\medskip

Suppose we wish to compute the $x$-coordinates of our sixty five points.
Then we must use an elimination order, for instance, the
one described in \cite[\S 3.2, Exercise 6.a]{CLO1}.
We define a  new polynomial ring with the elimination order
for $\{y,z\} > \{x\}$ as follows:
<<<S = QQ[z,y,x, MonomialOrder => Eliminate 2]>>>
We move our ideal into the new ring,
<<<ourpoints'' = substitute(ourpoints,S)>>>
and we compute the reduced Gr\"obner basis in this new order:
<<<G = gens gb ourpoints''>>>
To compute the elimination ideal we use the following command:
<<<ideal selectInSubring(1,G)>>>

\section{Monomials Under the Staircase}

Invariants of an algebraic variety, such as its dimension
and degree, are computed from an initial monomial ideal.
This computation amounts to the combinatorial task
of analyzing the collection of standard monomials,
that is, the monomials under the staircase \cite[Chapter 9]{CLO1}.
In this section we demonstrate some basic operations on
monomial ideals in \Mtwo.

Let us create a non-trivial staircase in three dimensions
by taking the third power of the initial monomial from line {\tt i20}.
<<<M = staircase^3>>>
The number of current generators of this ideal equals
<<<numgens M>>>
To see all generators we can transpose the matrix of minimal generators:
<<<transpose gens M>>>
Note that this generating set is not minimal; see {\tt o48} below.
The number of standard monomials equals
<<<degree M>>>
To list all the standard monomials we first create the residue ring
<<<S = R/M>>>
and then we ask for a vector space basis of the residue ring:
<<<basis S>>>
Let us count how many standard monomials there are of a given degree.
The following table represents the Hilbert function
of the residue ring.
<<<tally apply(flatten entries basis(S),degree)>>>
Thus the largest degree of a standard monomial is nineteen,
and there are three standard monomials of that degree:
<<<basis(19,S)>>>
The most recently defined ring involving {\tt x}, {\tt y}, and {\tt z} was
{\tt S}, so all computations involving those variables are done in the
residue ring {\tt S}.
%% The current ring {\tt S} is the residue ring. All calculations
%% are done in {\tt S}. 
For instance, we can also obtain the
standard monomials of  degree nineteen as follows:
<<<(x+y+z)^19>>>
An operation on ideals which will occur frequently throughout this
book is the computation of minimal free resolutions. This is done as follows:
<<<C = res M>>>
This shows that our ideal {\tt M} has sixteen minimal generators.
They are the entries in the leftmost matrix of the chain complex {\tt C}:
<<<C.dd_1>>>
This means that four of the twenty generators in {\tt o39} were redundant.
We construct the set consisting of the four redundant generators
as follows:
<<<set flatten entries gens M - set flatten entries C.dd_1>>>
Here {\tt flatten entries} turns the matrix ${\tt M}$ into a single list.
The command {\tt set} turns that list into a set, to which we
can apply the difference operation for sets.

Let us now take a look at the first syzygies 
(or {\it minimal S-pairs} \cite[\S 2.9]{CLO1})
among  the sixteen minimal generators.
They correspond to the columns of the second matrix in our resolution {\tt C}:
<<<C.dd_2>>>
The first column represents the S-pair between the
first generator $x^3 y^6 $ and the third generator $x^2 y^9$.
It is natural to form the {\it S-pair graph} with $16$ vertices and
$27$ edges represented by  this matrix. According to the
general theory described in \cite{MS}, this is a planar graph
with $12$ regions. The regions correspond to the $12$ second syzygies,
that is, to the columns of the matrix
<<<C.dd_3>>>
But we are getting ahead of ourselves. Homological algebra and resolutions
will be covered in the next chapter, and monomial ideals
will appear in the chapter of Ho\c{s}ten and Smith.
Let us return to Cox, Little and O'Shea \cite{CLO2}.

\section{Pennies, Nickels, Dimes and Quarters}

We now come to an application of Gr\"obner bases which appears in
\cite[Section 8.1]{CLO2}: {\sl Integer Programming}. This is the problem of
 minimizing a linear objective function over the set of non-negative 
integer solutions of a system of linear equations.  We demonstrate
some techniques for doing this in \Mtwo. Along the way, we learn about
multigraded polynomial rings and how to compute
Gr\"obner bases with respect to monomial orders defined by weights.
Our running example is the linear system defined  by the matrix:
<<<A = {{1, 1, 1, 1},
     {1, 5,10,25}}>>>
For the algebraic study of integer programming problems, a good starting
point is to work in a multigraded polynomial ring, here in four variables:
<<<R = QQ[p,n,d,q, Degrees => transpose A]>>>
The degree of each variable is the corresponding column vector of the matrix
Each variable represents one of the four coins in the U.S. currency system:
<<<degree d>>>
<<<degree q>>>
Each monomial represents a collection of coins. For instance, suppose
you own four  pennies, eight nickels, ten dimes, and three quarters:
<<<degree(p^4*n^8*d^10*q^3)>>>
Then you have a total of 25 coins worth two dollars and nineteen cents.
There are nine other possible ways of having 25 coins of the same value:
<<<h = basis({25,219}, R)>>>
For just counting the number of columns of this matrix
we can use the command
<<<rank source h>>>
How many ways can you make change for ten dollars using $100$ coins?
<<<rank source basis({100,1000}, R)>>>
A typical integer programming problem is this: among all 182 ways of
expressing ten dollars using 100 coins, which one uses the fewest dimes?
We set up the  Conti-Traverso algorithm \cite[\S 8.1]{CLO2} for 
answering this question. We use the following ring with the lexicographic
order and with the variable order:
dimes (d) before pennies (p) before nickels (n) before quarters (q).
<<<S = QQ[x, y, d, p, n, q, 
    MonomialOrder => Lex, MonomialSize => 16]>>>
The option {\tt MonomialSize} advises \Mtwo to use more space to store the
exponents of monomials, thereby avoiding a potential overflow.

We define an ideal with one generator for each column of the matrix A.
<<<I = ideal( p - x*y, n - x*y^5, d - x*y^10, q - x*y^25)>>>
The integer program is solved by normal form reduction with respect
to the following Gr\"obner basis consisting of binomials.
<<<transpose gens gb I>>>
We fix the quotient ring, so the reduction to normal form
will happen automatically.
<<<S' = S/I>>>
You need at least two dimes to express one dollar with ten coins.
<<<x^10 * y^100>>>
But you can express ten dollars with a hundred coins none of which is a dime.
<<<x^100 * y^1000>>>
The integer program is infeasible if and only if the normal form still
contains the variable $x$ or the variable $y$. For instance, you cannot
express ten dollars with less than forty coins:
<<<x^39 * y^1000>>>
We now introduce a new term order on the polynomial ring, defined
by assigning a weight to each variable. Specifically, we assign
weights for each of the coins. For instance,
let pennies have weight 5, nickels weight 7, 
dimes weight 13 and quarters weight 17.
<<<weight = (5,7,13,17)>>>
We set up a new ring with the resulting weight term order, and work modulo
the same ideal as before in this new ring.
<<<T = QQ[x, y, p, n, d, q, 
          Weights => {{1,1,0,0,0,0},{0,0,weight}},
          MonomialSize => 16]/
      (p - x*y, n - x*y^5, d - x*y^10, q - x*y^25);>>>
One dollar with ten coins:
<<<x^10 * y^100>>>
Ten dollars with one hundred coins:
<<<x^100 * y^1000>>>
Here is an optimal solution which involves all four types of coins:
<<<x^234 * y^5677>>>
